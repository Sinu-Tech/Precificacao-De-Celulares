# -*- coding: utf-8 -*-
"""PrecificacaoDeCelulares.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/github/Sinu-Tech/Precificacao-De-Celulares/blob/main/PrecificacaoDeCelulares.ipynb
"""

import pandas as pd
import os
import plotly.express as px
from sklearn.metrics import accuracy_score
from sklearn import preprocessing
from sklearn.tree import DecisionTreeClassifier
from sklearn.linear_model import Perceptron
from sklearn.neighbors import KNeighborsClassifier
from sklearn.naive_bayes import GaussianNB
from sklearn.svm import SVC

url_train = 'https://raw.githubusercontent.com/Sinu-Tech/Precificacao-De-Celulares/main/train.csv'
base_treino = pd.read_csv(url_train)

url_test = 'https://raw.githubusercontent.com/Sinu-Tech/Precificacao-De-Celulares/main/test.csv'
base_teste = pd.read_csv(url_test)

base_treino.describe()

base_treino.isnull().sum()

grafico = px.box(base_treino, y='battery_power')
grafico.show()

grafico = px.box(base_treino, y='clock_speed')
grafico.show()

grafico = px.box(base_treino, y='fc')
grafico.show()

grafico = px.box(base_treino, y='int_memory')
grafico.show()

grafico = px.box(base_treino, y='mobile_wt')
grafico.show()

grafico = px.box(base_treino, y='n_cores')
grafico.show()

grafico = px.box(base_treino, y='pc')
grafico.show()

grafico = px.box(base_treino, y='px_height')
grafico.show()

grafico = px.box(base_treino, y='px_width')
grafico.show()

grafico = px.box(base_treino, y='ram')
grafico.show()

grafico = px.box(base_treino, y='sc_h')
grafico.show()

grafico = px.box(base_treino, y='sc_w')
grafico.show()

grafico = px.box(base_treino, y='talk_time')
grafico.show()

grafico = px.box(base_treino, y='price_range')
grafico.show()

base_teste.drop(["id"], axis=1)

atributos = base_treino.iloc[:, :20]
print(atributos)

classes = base_treino.loc[:, ['price_range']]
print(classes)

def qt():
  qt = preprocessing.QuantileTransformer() 
  atributos_normalizados = qt.fit_transform(atributos)
  return  atributos_normalizados

def mas():
  mas = preprocessing.MaxAbsScaler()
  atributos_normalizados = mas.fit_transform(atributos)
  return  atributos_normalizados

def nm():
  nm = preprocessing.Normalizer()
  atributos_normalizados = nm.fit_transform(atributos)  
  return  atributos_normalizados

def ss():
  ss = preprocessing.StandardScaler()
  atributos_normalizados = ss.fit_transform(atributos)
  return  atributos_normalizados

def mms():
  mms = preprocessing.MinMaxScaler()
  atributos_normalizados = mms.fit_transform(atributos)
  return  atributos_normalizados

atributos_normalizados = mms()

"""Ericles"""

def decision_tree_classifier():

  modelo = DecisionTreeClassifier()
  modelo.fit(atributos_normalizados, classes)

  print(f'Acurácia: {modelo.score(atributos_normalizados, classes)*100}')

  pred = modelo.predict(atributos)

  print(f'Esperado: {classes}, resultado: {pred}')

def dtc(atributos_normalizados):
  modelo = DecisionTreeClassifier()
  modelo.fit(atributos_normalizados, classes)
  return modelo.score(atributos_normalizados, classes)*100

"""Joanne"""

def perceptron():

  modelo = Perceptron()
  modelo.fit(atributos_normalizados, classes)

  print(f'Acurácia: {modelo.score(atributos_normalizados, classes)*100}')

  pred = modelo.predict(atributos)

  print(f'Esperado: {classes}, resultado: {pred}')

def per(atributos_normalizados):
  modelo = Perceptron()
  modelo.fit(atributos_normalizados, classes)
  return modelo.score(atributos_normalizados, classes)*100

"""Milena"""

def naive_bayes():

  modelo = GaussianNB()
  modelo.fit(atributos_normalizados, classes)

  print(f'Acurácia: {modelo.score(atributos_normalizados, classes)*100}')

  pred = modelo.predict(atributos)

  print(f'Esperado: {classes}, resultado: {pred}')

def nai(atributos_normalizados):
  modelo = GaussianNB()
  modelo.fit(atributos_normalizados, classes)
  return modelo.score(atributos_normalizados, classes)*100

"""Kendy"""

def k_neighbors_classifier():

  modelo = KNeighborsClassifier(n_neighbors=3)
  modelo.fit(atributos_normalizados, classes)

  print(f'Acurácia: {modelo.score(atributos_normalizados, classes)*100}')

  pred = modelo.predict(atributos)

  print(f'Esperado: {classes}, resultado: {pred}')

def knn(atributos_normalizados):
  modelo = KNeighborsClassifier()
  modelo.fit(atributos_normalizados, classes)
  return modelo.score(atributos_normalizados, classes)*100

"""Thiago"""

def svc():

  modelo = SVC()
  modelo.fit(atributos_normalizados, classes)

  print(f'Acurácia: {modelo.score(atributos_normalizados, classes)*100}')

  pred = modelo.predict(atributos)

  print(f'Esperado: {classes}, resultado: {pred}')

def svm(atributos_normalizados):
  modelo = SVC()
  modelo.fit(atributos_normalizados, classes)
  return modelo.score(atributos_normalizados, classes)*100

"""Menu"""

def linha(tamanho=42):
    return '-' * tamanho


def cabecalho(menu):
    print(linha())
    print(menu.center(42))
    print(linha())


def algoritmos():
    print("1 - Árvore de decisão")
    print("2 - KNN")
    print("3 - Naive Bayes")
    print("4 - Perceptron")
    print("5 - SVC")
    print("6 - Sair")


def opcoes():
    op = '1' 
    while op!='0':
      os.system('cls')
      algoritmos();
      op = input("Digite o respectivo número referente ao algoritmo: ")
      if op=='1':
        decision_tree_classifier()
      elif op=='2':
        k_neighbors_classifier()
      elif op=='3':
        naive_bayes()
      elif op=='4':
        perceptron()
      elif op=='5':
        svc()
      elif op!='0':
        print('Opção inválida')
      input("Digite qualquer tecla para continuar: ")

"""Menu"""

cabecalho("ALGORITMOS DE CLASSIFICAÇÃO");
opcoes();

"""Comparações"""

resultados = {}

resultados['DecisionTreeClassifier-QuantileTransformer'] = dtc(qt())
resultados['Perceptron-QuantileTransformer'] = per(qt())
resultados['NaiveBayes-QuantileTransformer'] = nai(qt())
resultados['KNeighborsClassifier-QuantileTransformer'] = knn(qt())
resultados['SupportVectorMachine-QuantileTransformer'] = svm(qt())

resultados['DecisionTreeClassifier-MaxAbsScaler'] = dtc(mas())
resultados['Perceptron-MaxAbsScaler'] = per(mas())
resultados['NaiveBayes-MaxAbsScaler'] = nai(mas())
resultados['KNeighborsClassifier-MaxAbsScaler'] = knn(mas())
resultados['SupportVectorMachine-MaxAbsScaler'] = svm(mas())

resultados['DecisionTreeClassifier-Normalizer'] = dtc(nm())
resultados['Perceptron-Normalizer'] = per(nm())
resultados['NaiveBayes-Normalizer'] = nai(nm())
resultados['KNeighborsClassifier-Normalizer'] = knn(nm())
resultados['SupportVectorMachine-Normalizer'] = svm(nm())

resultados['DecisionTreeClassifier-StandardScaler'] = dtc(ss())
resultados['Perceptron-StandardScaler'] = per(ss())
resultados['NaiveBayes-StandardScaler'] = nai(ss())
resultados['KNeighborsClassifier-StandardScaler'] = knn(ss())
resultados['SupportVectorMachine-StandardScaler'] = svm(ss())

resultados['DecisionTreeClassifier-MinMaxScaler'] = dtc(mms())
resultados['Perceptron-MinMaxScaler'] = per(mms())
resultados['NaiveBayes-MinMaxScaler'] = nai(mms())
resultados['KNeighborsClassifier-MinMaxScaler'] = knn(mms())
resultados['SupportVectorMachine-MinMaxScaler'] = svm(mms())

for i in sorted(resultados, key = resultados.get, reverse=True):
    print(i, resultados[i])
    print('* * * ' * int(resultados[i]/10))